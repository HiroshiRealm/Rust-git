# RustGit

这是一个用 Rust 语言实现的简化版 Git。

## 功能

本项目旨在重新实现 Git 的一些核心功能，有助于深入了解 Git 的内部工作原理。

目前已实现以下命令：

*   `init`：初始化一个新的 Git 仓库。
*   `add`：将文件内容添加到索引。
*   `commit`：记录对仓库的更改。
*   `branch`：列出、创建或删除分支。
*   `checkout`：切换分支或恢复工作树文件。
*   `merge`：合并两个或多个开发历史。
*   `cat-file`：提供仓库对象的内容或类型和大小信息。
*   `status` 比较工作目录Workingdir,暂存区Index以及HEAD commit之间的区别
*   `rm`：从工作区和索引中删除文件。
*   `pull`：从远程仓库获取并集成。
*   `push`：更新远程引用以及关联的对象。
*   `fetch`：从另一个存储库下载对象和引用。

### 接下来需要支持的命令


## 模块

项目主要包含以下模块：

*   `commands`：实现了各个 Git 命令的逻辑。
*   `repository`：处理 Git 仓库的内部结构，包括对象（objects）、引用（refs）和索引（index）。

## 如何使用

### 编译运行
cargo build --release

构建出来的是一个verbose output版本的git,执行每一个git命令之后都会输出一些内容,方便开发和调试用. 

如果是需要提交到oj的rust-git可执行文件,需要

"cargo build --features online_judge --release"

之后运行rust-git即可.

### 提交

运行pack.sh 即会自动生成一个符合提交格式的压缩包,自动使用 "cargo build --features online_judge --release" 编译

注意需要在x86 ISA下编译才行,macOS本地编译的结果提交后是无法运行的.


### Help

rust-git -h/help 即可

## 远程命令实现 (Fetch, Pull, Push)

为了支持远程协作，我们实现了一套基于 HTTP 的 `fetch`, `pull` 和 `push` 命令。该实现的核心思路是利用 `git bundle` 的概念，将仓库的更新打包成单个文件进行传输。

### 核心理念：Git Bundle

我们没有直接传输零散的 Git 对象，而是将所有需要的 Git 对象和引用（Refs）打包成一个 `.tar.gz` 格式的压缩文件。这个单一的 bundle 文件包含了在两个仓库之间同步所需的所有信息。

- **Push 操作**: 客户端创建一个包含其新提交的 bundle 文件，并将其发送到服务器。
- **Fetch 操作**: 客户端从服务器请求一个包含最新历史的 bundle 文件，并在本地解包以更新其远程跟踪分支。

### 传输协议：哑 HTTP (Dumb HTTP)

我们实现了一个简单的"哑" HTTP 协议来交换 bundle 文件。

- **服务器**: 一个独立的 Rust 程序 (`src/bin/server.rs`)，使用 `axum` 框架构建。它在 `http://127.0.0.1:3000` 上监听，并提供一个端点：`/repo.bundle`。
  - `GET /repo.bundle`: 客户端执行 `fetch` 或 `pull` 时调用。服务器会实时将其本地 Git 仓库打包成一个 bundle 文件，并作为 HTTP 响应体发回。
  - `POST /repo.bundle`: 客户端执行 `push` 时调用。服务器接收 HTTP 请求体中的 bundle 文件，并在本地解包，以更新其仓库中的对象和分支。

- **客户端**: `fetch` 和 `push` 命令使用 `reqwest` 库来作为 HTTP 客户端。
  - `fetch`: 向服务器 URL 发送一个 `GET` 请求，并将收到的响应体（bundle 文件流）直接送入解包逻辑中。
  - `push`: 在内存中创建好 bundle 文件后，向服务器 URL 发送一个 `POST` 请求，将 bundle 作为请求体上传。

### 关键安全特性：非快进 (Non-Fast-Forward) 推送保护

为了防止在协作环境中意外覆盖他人的提交，服务器在处理 `push` 请求时实现了一个关键的安全检查。

- 在更新任何分支之前，服务器会检查当前分支的最新提交（HEAD）是否是客户端推送来的新提交的直接祖先。
- **快进 (Fast-Forward)**: 如果是直接祖先关系，说明推送是安全的，服务器会更新分支。
- **非快进 (Non-Fast-Forward)**: 如果不是直接祖先关系（意味着有其他人已经推送了新的更改），服务器会**拒绝**此次推送，并返回一个错误。这强制要求推送者必须先 `pull` 最新的代码，在本地合并后才能再次推送，从而保证了历史记录的完整性。

### 如何使用

1.  **启动服务器**:
    在一个终端中，使用以下命令为指定的 Git 仓库启动服务器。
    ```bash
    cargo run --bin server /path/to/your/server_repo
    ```

2.  **客户端操作**:
    在另一个终端中，你可以对该服务器执行远程操作。
    ```bash
    # 从服务器拉取更新
    rust-git pull origin http://127.0.0.1:3000/repo.bundle

    # 将本地更新推送到服务器
    rust-git push origin http://127.0.0.1:3000/repo.bundle
    ```

### 与真实 Git 协议的对比及未来改进

我们当前基于 HTTP 传输完整 bundle 的实现，虽然功能可用，但与 Git 的原生"智能协议"（Smart Protocol）相比，存在一些设计上的权衡，主要是为了简化实现。

**当前实现的优势与劣势：**

- **优势**:
  - **简单直观**: 整个逻辑非常清晰，将数据同步问题简化为了单个文件的传输问题。
  - **易于实现**: 无需实现复杂的"握手"和差异计算逻辑，复用了已有的 `bundle` 功能。

- **劣势 (性能和效率)**:
  - **数据冗余**: 我们的实现每次都会传输一个包含大量重复 Git 对象的 bundle 文件。即使用户只提交了一个很小的改动，整个仓库（或大部分）的对象也可能被重新打包并传输，造成了巨大的网络开销。
  - **服务器负载**: 服务器在每次 `fetch` 请求时都需要实时地将整个仓库打包并压缩成 `.tar.gz` 文件，这是一个消耗 CPU 和磁盘 I/O 的重量级操作。
  - **低效的引用发现**: 客户端必须下载整个 bundle 才能知道远程仓库有哪些分支和标签。

**Git 智能协议是如何工作的？**

真正的 Git 智能协议远比我们的实现高效。其大致流程如下：

1.  **握手 (Handshake)**: 客户端连接到服务器后，会先告诉服务器它本地拥有哪些分支的最新 commit ID。
2.  **差异计算**: 服务器根据客户端发来的信息，计算出客户端所缺少的、并且是这次请求所需要的最小对象集合。
3.  **瘦包 (Thin Pack)**: 服务器将这个最小化的对象集合打包成一个"瘦包"（thin packfile），并发送给客户端。这个包只包含客户端需要的数据，大大减少了传输量。

**未来可能的改进方向：**

为了让我们的实现更接近工业级标准，可以从以下几个方面进行改进：

1.  **实现协议握手**: 在客户端和服务器之间建立一个通信步骤，让它们可以交换各自的引用信息（分支和 commit ID）。
2.  **实现差异化打包**: 基于握手信息，在服务器端实现一个更智能的打包器，使其能够只打包客户端缺失的对象，生成"瘦包"。
3.  **实现 `upload-pack` 和 `receive-pack`**: 这两个是 Git 官方用来处理 `fetch` 和 `push` 流程的核心服务。最终目标是实现这两个服务，以达到与原生 Git 完全兼容和同样高效的水平。
