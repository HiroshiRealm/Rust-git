# RustGit

这是一个用 Rust 语言实现的简化版 Git。

## 功能

本项目旨在重新实现 Git 的一些核心功能，有助于深入了解 Git 的内部工作原理。

目前已实现以下命令：

*   `init`：初始化一个新的 Git 仓库。
*   `add`：将文件内容添加到索引。
*   `commit`：记录对仓库的更改。
*   `branch`：列出、创建或删除分支。
*   `checkout`：切换分支或恢复工作树文件。
*   `merge`：合并两个或多个开发历史。
*   `cat-file`：提供仓库对象的内容或类型和大小信息。
*   `status` 比较工作目录Workingdir,暂存区Index以及HEAD commit之间的区别
*   `rm`：从工作区和索引中删除文件。
*   `pull`：从远程仓库获取并集成。
*   `push`：更新远程引用以及关联的对象。
*   `fetch`：从另一个存储库下载对象和引用。
*   `remote`：管理远程仓库别名 (例如 `remote add origin <url>`)，配置存储在 `.git/config`。

### 接下来需要支持的命令


## 模块

项目主要包含以下模块：

*   `commands`：实现了各个 Git 命令的逻辑。
*   `repository`：处理 Git 仓库的内部结构，包括对象（objects）、引用（refs）和索引（index）。

## 如何使用

### 编译运行
cargo build --release

构建出来的是一个verbose output版本的git,执行每一个git命令之后都会输出一些内容,方便开发和调试用. 

如果是需要提交到oj的rust-git可执行文件,需要

"cargo build --features online_judge --release"

之后运行rust-git即可.

### 提交

运行pack.sh 即会自动生成一个符合提交格式的压缩包,自动使用 "cargo build --features online_judge --release" 编译

注意需要在x86 ISA下编译才行,macOS本地编译的结果提交后是无法运行的.


### Help

rust-git -h/help 即可

## 自动化测试

为了保证项目的稳定性和功能的正确性，我们编写了一套全面的端到端测试脚本，存放于 `tests/mytests/` 目录下。这些脚本会自动模拟真实的用户操作场景。

- `remote_alias_test.sh`: 核心功能测试。专门验证 `remote add` 添加别名后，能否成功使用该别名 (`origin`) 完成 `pull`, `fetch` 和 `push` 的完整工作流。
- `collaboration_test.sh`: 协作冲突测试。模拟两位客户端同时对一个远程仓库进行操作，验证当一位用户推送了新更改后，另一位用户的非快进 (Non-Fast-Forward) 推送会被服务器正确拒绝，从而保证数据安全。
- `local_bundle_test.sh`: 基础 HTTP 测试。验证基础的、通过网络进行 `pull` 和 `push` 的功能。

你可以通过在项目根目录运行 `bash ./tests/mytests/<script_name>.sh` 来执行这些测试。

## 远程命令实现 (Fetch, Pull, Push)

为了支持远程协作，我们实现了一套基于 HTTP 的 `fetch`, `pull` 和 `push` 命令。该实现的核心思路是利用 `git bundle` 的概念，将仓库的更新打包成单个文件进行传输。

### 核心理念：Git Bundle

我们没有直接传输零散的 Git 对象，而是将所有需要的 Git 对象和引用（Refs）打包成一个 `.tar.gz` 格式的压缩文件。这个单一的 bundle 文件包含了在两个仓库之间同步所需的所有信息。

- **Push 操作**: 客户端创建一个包含其新提交的 bundle 文件，并将其发送到服务器。
- **Fetch 操作**: 客户端从服务器请求一个包含最新历史的 bundle 文件，并在本地解包以更新其远程跟踪分支。

### 传输协议：哑 HTTP (Dumb HTTP)

我们实现了一个简单的"哑" HTTP 协议来交换 bundle 文件。

- **服务器**: 一个独立的 Rust 程序 (`src/bin/server.rs`)，使用 `axum` 框架构建。它在 `http://127.0.0.1:3000` 上监听，并提供一个端点：`/repo.bundle`。
  - `GET /repo.bundle`: 客户端执行 `fetch` 或 `pull` 时调用。服务器会实时将其本地 Git 仓库打包成一个 bundle 文件，并作为 HTTP 响应体发回。
  - `POST /repo.bundle`: 客户端执行 `push` 时调用。服务器接收 HTTP 请求体中的 bundle 文件，并在本地解包，以更新其仓库中的对象和分支。

- **客户端**: `fetch` 和 `push` 命令使用 `reqwest` 库来作为 HTTP 客户端。
  - `fetch`: 向服务器 URL 发送一个 `GET` 请求，并将收到的响应体（bundle 文件流）直接送入解包逻辑中。
  - `push`: 在内存中创建好 bundle 文件后，向服务器 URL 发送一个 `POST` 请求，将 bundle 作为请求体上传。

### 关键安全特性：非快进 (Non-Fast-Forward) 推送保护

为了防止在协作环境中意外覆盖他人的提交，服务器在处理 `push` 请求时实现了一个关键的安全检查。

- 在更新任何分支之前，服务器会检查当前分支的最新提交（HEAD）是否是客户端推送来的新提交的直接祖先。
- **快进 (Fast-Forward)**: 如果是直接祖先关系，说明推送是安全的，服务器会更新分支。
- **非快进 (Non-Fast-Forward)**: 如果不是直接祖先关系（意味着有其他人已经推送了新的更改），服务器会**拒绝**此次推送，并返回一个错误。这强制要求推送者必须先 `pull` 最新的代码，在本地合并后才能再次推送，从而保证了历史记录的完整性。

### 如何使用

1.  **启动服务器**:
    在一个终端中，使用以下命令为指定的 Git 仓库启动服务器。
    ```bash
    cargo run --bin server /path/to/your/server_repo
    ```

2.  **客户端操作**:
    在另一个终端中，你可以对该服务器执行远程操作。
    ```bash
    # 在你的本地仓库中
    # 1. 添加一个远程仓库的别名，指向服务器地址
    rust-git remote add origin http://127.0.0.1:3000/repo.bundle
    
    # 2. 从服务器拉取更新
    rust-git pull origin

    # 3. 将本地更新推送到服务器
    rust-git push origin
    
    # 你也可以直接对一个 URL 进行一次性推送
    rust-git push http://127.0.0.1:3000/repo.bundle
    ```

### 与真实 Git 协议的对比及未来改进

我们当前基于 HTTP 传输完整 bundle 的实现，虽然功能可用，但与 Git 的原生"智能协议"（Smart Protocol）相比，存在一些设计上的权衡，主要是为了简化实现。

**当前实现的优势与劣势：**

- **优势**:
  - **简单直观**: 整个逻辑非常清晰，将数据同步问题简化为了单个文件的传输问题。
  - **易于实现**: 无需实现复杂的"握手"和差异计算逻辑，复用了已有的 `bundle` 功能。

- **劣势 (性能和效率)**:
  - **数据冗余**: 我们的实现每次都会传输一个包含大量重复 Git 对象的 bundle 文件。即使用户只提交了一个很小的改动，整个仓库（或大部分）的对象也可能被重新打包并传输，造成了巨大的网络开销。
  - **服务器负载**: 服务器在每次 `fetch` 请求时都需要实时地将整个仓库打包并压缩成 `.tar.gz` 文件，这是一个消耗 CPU 和磁盘 I/O 的重量级操作。
  - **低效的引用发现**: 客户端必须下载整个 bundle 才能知道远程仓库有哪些分支和标签。

**Git 智能协议是如何工作的？**

真正的 Git 智能协议远比我们的实现高效。其大致流程如下：

1.  **握手 (Handshake)**: 客户端连接到服务器后，会先告诉服务器它本地拥有哪些分支的最新 commit ID。
2.  **差异计算**: 服务器根据客户端发来的信息，计算出客户端所缺少的、并且是这次请求所需要的最小对象集合。
3.  **瘦包 (Thin Pack)**: 服务器将这个最小化的对象集合打包成一个"瘦包"（thin packfile），并发送给客户端。这个包只包含客户端需要的数据，大大减少了传输量。

**未来可能的改进方向：**

为了让我们的实现更接近工业级标准，可以从以下几个方面进行改进：

1.  **实现协议握手**: 在客户端和服务器之间建立一个通信步骤，让它们可以交换各自的引用信息（分支和 commit ID）。
2.  **实现差异化打包**: 基于握手信息，在服务器端实现一个更智能的打包器，使其能够只打包客户端缺失的对象，生成"瘦包"。
3.  **实现 `upload-pack` 和 `receive-pack`**: 这两个是 Git 官方用来处理 `fetch` 和 `push` 流程的核心服务。最终目标是实现这两个服务，以达到与原生 Git 完全兼容和同样高效的水平。

## 架构探讨与未来展望

### 关于 `.git` 目录中的状态文件

在当前的实现中，我们像真实的 Git 一样，将仓库的状态"指针"存储在 `.git` 目录下的多个独立文件中。例如：
- `HEAD`: 指向当前所在的分支。
- `refs/heads/master`: 指向 `master` 分支的最新 commit ID。
- `refs/remotes/origin/master`: 指向远程 `origin` 的 `master` 分支的最新 commit ID。

这是一个非常简单和直观的设计，可以直接通过标准命令行工具 (`cat`, `echo`) 进行查看和操作，也反映了 Git 早期的设计哲学。

### 一个新的想法：统一的状态文件

一个有趣的架构改进思路是：能否将所有这些分散的状态"指针"整合到一个统一的、结构化的文件中（例如，一个名为 `.git/state` 的文件）？

**这种设计的潜在优势：**
1.  **原子性**: 更新单个文件通常比更新多个文件更具原子性。如果一次复杂的操作（如 `pull`）需要更新多个 ref，但在中途被打断，可能会导致仓库状态不一致。而更新单个文件可以更容易地保证事务的完整性。
2.  **性能**: 对于需要读取大量引用的操作，一次性读取并解析一个文件可能比多次单独读取分散的小文件性能更高，减少了文件 I/O 的开销。

**Git 的演化与权衡 (`packed-refs`)**

有趣的是，Git 的开发者们也早已意识到了这个问题。随着仓库中分支和标签数量的增多，`refs` 目录下的文件会变得越来越多，影响性能。因此，Git 引入了一个优化机制：`packed-refs` 文件。

- **`packed-refs` 文件**: 这是一个位于 `.git/packed-refs` 的单一文件。Git 会定期将 `refs/` 目录下大量不经常变动的引用（比如旧的分支或标签）打包到这个文件中，并删除原来的独立文件。
- **混合模式**: 现代 Git 采用的是一种**混合模式**。它会首先在独立的 loose ref 文件中寻找引用（例如 `refs/heads/master`），因为这些文件代表着最常被更新的引用。如果找不到，它才会去查询 `packed-refs` 这个"数据库"。

这种混合模式是性能与简单性之间一个绝佳的权衡。它既保留了直接操作高频更新的 ref (如 `HEAD` 和当前分支) 的简便性，又通过打包大量低频引用的方式解决了性能问题。

**未来的改进方向：**
我们当前的实现已经可以在 `bundle` 时创建 `packed-refs` 文件。一个非常有价值的未来改进方向，就是让我们的 `Repository` 模块也实现完整的混合模式：在读取引用时，能同时查询 loose ref 文件和 `packed-refs` 文件，并实现将 loose refs 打包进 `packed-refs` 的垃圾回收（`gc`）机制。这将使我们的实现在性能和健壮性上都向原生 Git 更进一步。
